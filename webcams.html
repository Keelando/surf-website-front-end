<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>Coastal Webcams | Salish Sea Live Views</title>

  <meta name="description" content="Live webcam views from coastal locations around the Salish Sea, including White Rock Pier and Boundary Bay." />
  <meta name="keywords" content="Salish Sea webcams, White Rock Pier camera, coastal webcams, BC beach webcams, live ocean views, marine webcams, Boundary Bay" />

  <link rel="canonical" href="https://halibutbank.ca/webcams.html" />
  <link rel="stylesheet" href="/assets/css/style-v4.css?v=20251112" />
  <link rel="stylesheet" href="/assets/css/nav-tide-styles-v4.css" />
  <link rel="stylesheet" href="/assets/css/warning-banner-v4.css" />

  <style>
    .webcam-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(500px, 1fr));
      gap: 2rem;
      margin: 2rem auto;
      max-width: 1200px;
      padding: 0 1rem;
      justify-content: center;
    }

    .webcam-card {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      transition: box-shadow 0.2s;
      max-width: 100%;
    }

    .webcam-card:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .webcam-header {
      background: linear-gradient(to right, #004b7c, #005a94);
      color: white;
      padding: 1rem 1.5rem;
    }

    .webcam-header h3 {
      margin: 0 0 0.25rem 0;
      font-size: 1.3rem;
    }

    .webcam-location {
      font-size: 0.9rem;
      opacity: 0.9;
      margin: 0;
    }

    .webcam-image-container {
      position: relative;
      width: 100%;
      max-width: 100%;
      background: #f0f0f0;
      min-height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .webcam-image {
      width: 100%;
      max-width: 100%;
      height: auto;
      display: block;
      object-fit: contain;
    }

    .slideshow-controls {
      display: none; /* Hidden until slideshow data loads */
      padding: 0.75rem;
      background: #f7fafc;
      border-top: 1px solid #e2e8f0;
      align-items: center;
      justify-content: center;
      gap: 1rem;
    }

    .slideshow-nav {
      background: #4299e1;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      cursor: pointer;
      font-size: 1.2rem;
      border-radius: 4px;
      transition: background 0.2s, opacity 0.2s;
      min-width: 40px;
    }

    .slideshow-nav:hover:not(:disabled) {
      background: #3182ce;
    }

    .slideshow-nav:disabled {
      opacity: 0.3;
      cursor: not-allowed;
      background: #cbd5e0;
    }

    .slideshow-dots {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .slideshow-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #cbd5e0;
      border: none;
      cursor: pointer;
      transition: background 0.2s, transform 0.2s;
    }

    .slideshow-dot:hover {
      transform: scale(1.2);
    }

    .slideshow-dot.active {
      background: #4299e1;
    }

    .webcam-loading {
      color: #718096;
      font-style: italic;
    }

    .webcam-info {
      padding: 1rem 1.5rem;
      background: #f7fafc;
    }

    .webcam-update-notice {
      font-size: 0.9rem;
      color: #2c5282;
      background: #e6f2ff;
      padding: 0.5rem;
      margin-bottom: 0.75rem;
      border-radius: 4px;
      text-align: center;
      font-weight: 500;
    }

    .webcam-timestamp {
      font-size: 0.85rem;
      color: #4a5568;
      margin-bottom: 0.5rem;
    }

    .slideshow-age-indicator {
      font-size: 0.8rem;
      color: #718096;
      font-style: italic;
      margin-top: 0.25rem;
    }

    .webcam-source {
      font-size: 0.85rem;
      color: #4a5568;
    }

    .webcam-source a {
      color: #4299e1;
      text-decoration: none;
    }

    .webcam-source a:hover {
      text-decoration: underline;
    }

    .webcam-conditions {
      background: #f7fafc;
      padding: 1rem 1.5rem;
      border-bottom: 2px solid #e2e8f0;
    }

    .condition-row {
      display: flex;
      align-items: baseline;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      font-size: 0.95rem;
    }

    .condition-row:last-child {
      margin-bottom: 0;
    }

    .condition-label {
      font-weight: 600;
      color: #2c5282;
      min-width: 120px;
    }

    .condition-value {
      color: #4a5568;
      font-weight: 500;
    }

    .condition-separator {
      color: #cbd5e0;
      margin: 0 0.25rem;
    }

    .webcam-data-stale {
      opacity: 0.5;
      font-style: italic;
    }

    .refresh-button {
      display: inline-block;
      padding: 0.5rem 1rem;
      background: #4299e1;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      margin-top: 0.5rem;
      transition: background 0.2s;
    }

    .refresh-button:hover {
      background: #3182ce;
    }

    .webcam-error {
      padding: 1rem;
      background: #fff5f5;
      color: #c53030;
      border-radius: 4px;
      margin: 1rem;
      text-align: center;
    }

    /* Mobile and tablet responsive */
    @media (max-width: 1024px) {
      .webcam-grid {
        grid-template-columns: 1fr;
        padding: 0 1rem;
      }
    }

    @media (max-width: 768px) {
      .webcam-grid {
        grid-template-columns: 1fr;
        gap: 1.5rem;
        padding: 0 0.5rem;
      }

      .webcam-image-container {
        min-height: 200px;
      }
    }

    @media (max-width: 550px) {
      .webcam-grid {
        grid-template-columns: 1fr;
        padding: 0 0.25rem;
      }
    }
  </style>
</head>
<body>
  <!-- Warning banners container -->
  <div hx-get="/components/warning-banner.html?v=1" hx-trigger="load" hx-swap="outerHTML swap:0ms settle:0ms"></div>

  <div hx-get="/components/nav.html?v=1" hx-trigger="load" hx-swap="outerHTML swap:0ms settle:0ms" style="min-height: 60px;"></div>

  <div hx-get="/components/header-webcams.html?v=1" hx-trigger="load" hx-swap="outerHTML swap:0ms settle:0ms" style="min-height: 80px;"></div>

  <div hx-get="/components/tagline-webcams.html?v=1" hx-trigger="load" hx-swap="outerHTML swap:0ms settle:0ms" style="min-height: 40px;"></div>

  <div class="container">
    <section style="background: #edf2f7; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;">
      <h2 style="margin-top: 0; color: #2c5282; font-size: 1.3rem;">About Coastal Webcams</h2>
      <p style="margin-bottom: 0.5rem;">
        Live and near-live views from coastal webcams around the Salish Sea.
        Images are updated every 10 minutes to provide current visual conditions for beaches, piers, and marine areas.
      </p>
      <p style="margin-bottom: 0.5rem;">
        <strong>Important:</strong> Due to YouTube livestream latency, still images are delayed by 6-20 minutes from real-time.
        For current conditions, click "View Source" to watch the live stream directly.
      </p>
      <p style="margin: 0;">
        <strong>Note:</strong> Check the timestamp on each image for exact capture time.
      </p>
    </section>

    <div id="webcams-container" class="webcam-grid">
      <!-- Webcams will be loaded here -->
    </div>
  </div>

  <!-- About Section -->
  <div hx-get="/components/about-generic.html?v=1" hx-trigger="load" hx-swap="outerHTML"></div>

  <!-- Navigation (Bottom) -->
  <div hx-get="/components/nav.html?v=1" hx-trigger="load" hx-swap="outerHTML"></div>

  <div hx-get="/components/footer.html?v=1" hx-trigger="load" hx-swap="outerHTML"></div>

  <script src="/assets/js/warning-banner.js"></script>
  <script>
    // Webcam configuration
    const webcams = [
      {
        id: 'whiterock',
        name: 'White Rock Pier',
        location: 'White Rock, BC',
        dataUrl: '/data/wrcam/latest.json',
        imageUrl: '/data/wrcam/latest.jpg',
        slideshowUrl: '/data/wrcam/slideshow_manifest.json',
        slideshowPath: '/data/wrcam/',
        streamDelay: 6,  // minutes
        conditions: [
          {
            label: 'East Beach Wind',
            windStation: 'CZBB',  // Boundary Bay Airport
            fields: ['wind_speed_only']
          },
          {
            label: 'Crescent Pile',
            buoyStation: 'CRPILE',
            fields: ['wind', 'waves']
          }
        ]
      },
      {
        id: 'boundarybay',
        name: 'Boundary Bay',
        location: 'Boundary Bay, BC',
        dataUrl: '/data/bbcam/latest.json',
        imageUrl: '/data/bbcam/latest.jpg',
        slideshowUrl: '/data/bbcam/slideshow_manifest.json',
        slideshowPath: '/data/bbcam/',
        streamDelay: 20,  // minutes
        conditions: [
          {
            label: 'East Beach Wind',
            windStation: 'CZBB',
            fields: ['wind_speed_only']
          },
          {
            label: 'Crescent Pile',
            buoyStation: 'CRPILE',
            fields: ['wind', 'waves']
          }
        ]
      }
    ];

    // Format timestamp for display (24-hour format)
    function formatTimestamp(isoString) {
      const date = new Date(isoString);
      const options = {
        timeZone: 'America/Vancouver',
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false,
        timeZoneName: 'short'
      };
      return date.toLocaleString('en-US', options);
    }

    // Fetch marine data (buoy and wind data)
    let cachedMarineData = null;
    async function fetchMarineData() {
      if (cachedMarineData) return cachedMarineData;

      try {
        const [buoyResponse, windResponse] = await Promise.all([
          fetch('/data/latest_buoy_v2.json'),
          fetch('/data/latest_wind.json')
        ]);

        const buoyData = buoyResponse.ok ? await buoyResponse.json() : {};
        const windData = windResponse.ok ? await windResponse.json() : {};

        cachedMarineData = { buoy: buoyData, wind: windData };
        return cachedMarineData;
      } catch (error) {
        console.error('Failed to fetch marine data:', error);
        return { buoy: {}, wind: {} };
      }
    }

    // Create conditions display element
    function createConditionsDisplay(webcam, marineData) {
      if (!webcam.conditions || !marineData) return null;

      const container = document.createElement('div');
      container.className = 'webcam-conditions';

      for (const condition of webcam.conditions) {
        const row = document.createElement('div');
        row.className = 'condition-row';

        const label = document.createElement('span');
        label.className = 'condition-label';
        label.textContent = condition.label + ':';
        row.appendChild(label);

        const valueSpan = document.createElement('span');
        valueSpan.className = 'condition-value';

        let valueParts = [];

        // Wind station data
        if (condition.windStation) {
          const windStation = marineData.wind[condition.windStation];
          if (windStation && !windStation.stale) {
            if (condition.fields.includes('wind_speed_only')) {
              if (windStation.wind_speed_kt !== null && windStation.wind_speed_kt !== undefined) {
                valueParts.push(`${windStation.wind_speed_kt.toFixed(1)} kt`);
              }
            }
          }
        }

        // Buoy station data
        if (condition.buoyStation) {
          const buoyStation = marineData.buoy[condition.buoyStation];
          if (buoyStation && !buoyStation.stale) {
            if (condition.fields.includes('wind')) {
              if (buoyStation.wind_speed !== null && buoyStation.wind_speed !== undefined) {
                let windStr = `${buoyStation.wind_speed.toFixed(1)} kt`;
                if (buoyStation.wind_direction_cardinal) {
                  windStr += ` ${buoyStation.wind_direction_cardinal}`;
                }
                valueParts.push(windStr);
              }
            }

            if (condition.fields.includes('waves')) {
              if (buoyStation.wave_height_sig !== null && buoyStation.wave_height_sig !== undefined &&
                  buoyStation.wave_period_avg !== null && buoyStation.wave_period_avg !== undefined) {
                valueParts.push(`${buoyStation.wave_height_sig.toFixed(2)}m @ ${buoyStation.wave_period_avg.toFixed(1)}s`);
              }
            }
          }
        }

        if (valueParts.length > 0) {
          valueSpan.innerHTML = valueParts.join(' <span class="condition-separator">|</span> ');
          row.appendChild(valueSpan);
          container.appendChild(row);
        }
      }

      // Only return if we have data to show
      return container.children.length > 0 ? container : null;
    }

    // Slideshow state (per webcam)
    const slideshowState = {};

    // Create webcam card
    async function createWebcamCard(webcam, metadata, buoyData) {
      const card = document.createElement('div');
      card.className = 'webcam-card';
      card.dataset.webcamId = webcam.id;

      // Header
      const header = document.createElement('div');
      header.className = 'webcam-header';

      const title = document.createElement('h3');
      title.textContent = webcam.name;

      const location = document.createElement('p');
      location.className = 'webcam-location';
      location.textContent = webcam.location;

      header.appendChild(title);
      header.appendChild(location);
      card.appendChild(header);

      // Image container
      const imageContainer = document.createElement('div');
      imageContainer.className = 'webcam-image-container';

      const image = document.createElement('img');
      image.className = 'webcam-image';
      image.src = webcam.imageUrl + '?t=' + Date.now();
      image.alt = webcam.name + ' webcam view';
      image.loading = 'lazy';

      imageContainer.appendChild(image);
      card.appendChild(imageContainer);

      // Slideshow controls container (below image)
      const controlsContainer = document.createElement('div');
      controlsContainer.className = 'slideshow-controls';

      // Previous button (shows older images)
      const prevBtn = document.createElement('button');
      prevBtn.className = 'slideshow-nav prev';
      prevBtn.innerHTML = '‹';
      prevBtn.onclick = () => navigateSlideshow(webcam.id, 1); // +1 = older (higher index)

      // Dots container
      const dotsContainer = document.createElement('div');
      dotsContainer.className = 'slideshow-dots';

      // Next button (shows newer images)
      const nextBtn = document.createElement('button');
      nextBtn.className = 'slideshow-nav next';
      nextBtn.innerHTML = '›';
      nextBtn.onclick = () => navigateSlideshow(webcam.id, -1); // -1 = newer (lower index)

      controlsContainer.appendChild(prevBtn);
      controlsContainer.appendChild(dotsContainer);
      controlsContainer.appendChild(nextBtn);
      card.appendChild(controlsContainer);

      // Load slideshow data
      loadSlideshow(webcam);

      // Info section
      const info = document.createElement('div');
      info.className = 'webcam-info';

      // Update notice with delay info
      const updateNotice = document.createElement('div');
      updateNotice.className = 'webcam-update-notice';
      updateNotice.textContent = `Updated every 10 minutes • ~${webcam.streamDelay} min stream delay`;
      info.appendChild(updateNotice);

      // Marine data display (wind/wave conditions)
      if (buoyData) {
        const marineDataEl = createMarineDataDisplay(webcam, buoyData);
        if (marineDataEl) {
          info.appendChild(marineDataEl);
        }
      }

      if (metadata) {
        const timestamp = document.createElement('div');
        timestamp.className = 'webcam-timestamp';
        timestamp.textContent = 'Last updated: ' + formatTimestamp(metadata.timestamp);
        info.appendChild(timestamp);

        if (metadata.source || metadata.url) {
          const source = document.createElement('div');
          source.className = 'webcam-source';

          if (metadata.url) {
            const link = document.createElement('a');
            link.href = metadata.url;
            link.target = '_blank';
            link.rel = 'noopener noreferrer';
            link.textContent = metadata.source || 'View Source';
            source.appendChild(document.createTextNode('Source: '));
            source.appendChild(link);
          } else {
            source.textContent = 'Source: ' + metadata.source;
          }

          info.appendChild(source);
        }

        // Refresh button
        const refreshBtn = document.createElement('button');
        refreshBtn.className = 'refresh-button';
        refreshBtn.textContent = 'Refresh Image';
        refreshBtn.onclick = async () => {
          image.src = webcam.imageUrl + '?t=' + Date.now();
          loadWebcamMetadata(webcam, card);

          // Reset slideshow to newest image and update dots
          const state = slideshowState[webcam.id];
          if (state) {
            state.currentIndex = 0;
            updateSlideshowDisplay(webcam.id);
          }

          // Refresh marine data
          cachedBuoyData = null;
          const freshBuoyData = await fetchMarineData();
          if (freshBuoyData) {
            const existingDataDisplay = card.querySelector('.webcam-data-display');
            const newDataDisplay = createMarineDataDisplay(webcam, freshBuoyData);

            if (existingDataDisplay && newDataDisplay) {
              existingDataDisplay.replaceWith(newDataDisplay);
            } else if (!existingDataDisplay && newDataDisplay) {
              const updateNotice = info.querySelector('.webcam-update-notice');
              if (updateNotice && updateNotice.nextSibling) {
                info.insertBefore(newDataDisplay, updateNotice.nextSibling);
              }
            }
          }
        };
        info.appendChild(refreshBtn);
      }

      card.appendChild(info);
      return card;
    }

    // Load metadata for a webcam
    async function loadWebcamMetadata(webcam, card) {
      try {
        const response = await fetch(webcam.dataUrl);
        const metadata = await response.json();

        // Update timestamp if card exists
        if (card) {
          const timestampEl = card.querySelector('.webcam-timestamp');
          if (timestampEl) {
            timestampEl.textContent = 'Last updated: ' + formatTimestamp(metadata.timestamp);
          }
        }

        return metadata;
      } catch (error) {
        console.error('Failed to load metadata for ' + webcam.name + ':', error);
        return null;
      }
    }

    // Load all webcams
    async function loadWebcams() {
      const container = document.getElementById('webcams-container');

      if (webcams.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #718096; padding: 2rem;">No webcams currently available.</p>';
        return;
      }

      container.innerHTML = '';

      // Fetch buoy data once for all webcams
      const buoyData = await fetchMarineData();

      for (const webcam of webcams) {
        try {
          const metadata = await loadWebcamMetadata(webcam);
          const card = await createWebcamCard(webcam, metadata, buoyData);
          container.appendChild(card);
        } catch (error) {
          console.error('Failed to load webcam ' + webcam.name + ':', error);

          const errorCard = document.createElement('div');
          errorCard.className = 'webcam-card';
          errorCard.innerHTML = `
            <div class="webcam-header">
              <h3>${webcam.name}</h3>
              <p class="webcam-location">${webcam.location}</p>
            </div>
            <div class="webcam-error">
              Failed to load webcam data. Please try again later.
            </div>
          `;
          container.appendChild(errorCard);
        }
      }
    }

    // Load slideshow manifest and setup navigation
    async function loadSlideshow(webcam) {
      try {
        const response = await fetch(webcam.slideshowUrl + '?t=' + Date.now());
        if (!response.ok) {
          console.warn('Slideshow not available for ' + webcam.name);
          return;
        }

        const manifest = await response.json();
        if (!manifest || manifest.length === 0) {
          console.warn('No slideshow images for ' + webcam.name);
          return;
        }

        // Store slideshow state
        slideshowState[webcam.id] = {
          images: manifest,
          currentIndex: 0, // Start with newest image
          basePath: webcam.slideshowPath
        };

        // Show navigation controls
        const card = document.querySelector(`[data-webcam-id="${webcam.id}"]`);
        if (card && manifest.length > 1) {
          const controlsContainer = card.querySelector('.slideshow-controls');
          const dotsContainer = card.querySelector('.slideshow-dots');

          controlsContainer.style.display = 'flex';

          // Clear existing dots before creating new ones (prevents duplicates on refresh)
          dotsContainer.innerHTML = '';

          // Create dots in reverse order (rightmost = newest)
          manifest.slice().reverse().forEach((img, reverseIndex) => {
            const actualIndex = manifest.length - 1 - reverseIndex;
            const dot = document.createElement('div');
            dot.className = 'slideshow-dot' + (actualIndex === 0 ? ' active' : '');
            dot.dataset.index = actualIndex;
            dot.onclick = () => goToSlide(webcam.id, actualIndex);
            dotsContainer.appendChild(dot);
          });
        }

      } catch (error) {
        console.error('Failed to load slideshow for ' + webcam.name + ':', error);
      }
    }

    // Navigate slideshow (no looping)
    function navigateSlideshow(webcamId, direction) {
      const state = slideshowState[webcamId];
      if (!state || !state.images) return;

      const newIndex = state.currentIndex + direction;

      // Don't allow looping - clamp to valid range
      if (newIndex < 0 || newIndex >= state.images.length) return;

      state.currentIndex = newIndex;
      updateSlideshowDisplay(webcamId);
    }

    // Go to specific slide
    function goToSlide(webcamId, index) {
      const state = slideshowState[webcamId];
      if (!state || !state.images) return;

      state.currentIndex = index;
      updateSlideshowDisplay(webcamId);
    }

    // Update slideshow display
    function updateSlideshowDisplay(webcamId) {
      const state = slideshowState[webcamId];
      if (!state) return;

      const card = document.querySelector(`[data-webcam-id="${webcamId}"]`);
      if (!card) return;

      const image = card.querySelector('.webcam-image');
      const currentImage = state.images[state.currentIndex];

      // Update image src
      image.src = state.basePath + currentImage.path + '?t=' + Date.now();

      // Update timestamp
      const timestamp = card.querySelector('.webcam-timestamp');
      if (timestamp) {
        const capturedTime = new Date(currentImage.timestamp);
        timestamp.textContent = 'Captured: ' + formatTimestamp(currentImage.timestamp);

        // Add age indicator if not the latest image
        let ageIndicator = card.querySelector('.slideshow-age-indicator');
        if (state.currentIndex > 0) {
          const minutesAgo = state.currentIndex * 10; // Images are 10 minutes apart
          if (!ageIndicator) {
            ageIndicator = document.createElement('div');
            ageIndicator.className = 'slideshow-age-indicator';
            timestamp.parentNode.insertBefore(ageIndicator, timestamp.nextSibling);
          }
          ageIndicator.textContent = `(${minutesAgo} minutes ago)`;
        } else if (ageIndicator) {
          ageIndicator.remove();
        }
      }

      // Update navigation buttons (disable at ends, no looping)
      const prevBtn = card.querySelector('.slideshow-nav.prev');
      const nextBtn = card.querySelector('.slideshow-nav.next');

      // At latest (index 0): can't go newer (right), can go older (left)
      // At oldest (max index): can't go older (left), can go newer (right)
      if (prevBtn) prevBtn.disabled = state.currentIndex === state.images.length - 1; // Disable left at oldest
      if (nextBtn) nextBtn.disabled = state.currentIndex === 0; // Disable right at newest

      // Update dots (dots are in reverse order, so match by data-index)
      const dots = card.querySelectorAll('.slideshow-dot');
      dots.forEach((dot) => {
        const dotIndex = parseInt(dot.dataset.index);
        dot.classList.toggle('active', dotIndex === state.currentIndex);
      });
    }

    // Auto-refresh webcams every 5 minutes (up to 30 minutes, then stop)
    function startAutoRefresh() {
      const REFRESH_INTERVAL = 5 * 60 * 1000; // 5 minutes
      const MAX_REFRESH_TIME = 30 * 60 * 1000; // 30 minutes
      const startTime = Date.now();
      let refreshCount = 0;

      const intervalId = setInterval(() => {
        const elapsed = Date.now() - startTime;

        // Stop auto-refresh after 30 minutes
        if (elapsed >= MAX_REFRESH_TIME) {
          clearInterval(intervalId);
          console.log('Auto-refresh stopped after 30 minutes. Refresh page to resume.');
          showRefreshNotice();
          return;
        }

        refreshCount++;
        console.log(`Auto-refreshing webcam images... (${refreshCount}/6)`);

        // Clear marine data cache to force refresh
        cachedBuoyData = null;

        // Reload marine data and update all webcam cards
        fetchMarineData().then(buoyData => {
          webcams.forEach(webcam => {
            const card = document.querySelector(`[data-webcam-id="${webcam.id}"]`);
            if (!card) return;

            // Only refresh image if viewing the latest (index 0)
            const state = slideshowState[webcam.id];
            if (!state || state.currentIndex === 0) {
              const image = card.querySelector('.webcam-image');
              image.src = webcam.imageUrl + '?t=' + Date.now();
            }

            // Update marine data display
            if (buoyData) {
              const existingDataDisplay = card.querySelector('.webcam-data-display');
              const newDataDisplay = createMarineDataDisplay(webcam, buoyData);

              if (existingDataDisplay && newDataDisplay) {
                existingDataDisplay.replaceWith(newDataDisplay);
              } else if (!existingDataDisplay && newDataDisplay) {
                const info = card.querySelector('.webcam-info');
                const updateNotice = info.querySelector('.webcam-update-notice');
                if (updateNotice && updateNotice.nextSibling) {
                  info.insertBefore(newDataDisplay, updateNotice.nextSibling);
                }
              }
            }

            // Reload slideshow manifest
            loadSlideshow(webcam);
            loadWebcamMetadata(webcam, card);
          });
        });
      }, REFRESH_INTERVAL);
    }

    // Show notice when auto-refresh stops
    function showRefreshNotice() {
      const notice = document.createElement('div');
      notice.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #2c5282;
        color: white;
        padding: 1rem 2rem;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 1000;
        font-size: 0.95rem;
        text-align: center;
      `;
      notice.innerHTML = `
        Auto-refresh stopped after 30 minutes
        <button onclick="location.reload()" style="
          margin-left: 1rem;
          padding: 0.5rem 1rem;
          background: white;
          color: #2c5282;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-weight: 600;
        ">Refresh Page</button>
      `;
      document.body.appendChild(notice);

      // Auto-hide notice after 10 seconds
      setTimeout(() => {
        notice.style.transition = 'opacity 0.5s';
        notice.style.opacity = '0';
        setTimeout(() => notice.remove(), 500);
      }, 10000);
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
      loadWebcams();
      startAutoRefresh();
    });

    // Also load immediately if DOM is already ready
    if (document.readyState === 'loading') {
      // Already set up listener above
    } else {
      loadWebcams();
      startAutoRefresh();
    }
  </script>
  <script src="https://unpkg.com/htmx.org@1.9.10"></script>
</body>
</html>
