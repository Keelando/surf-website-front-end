<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>Coastal Webcams | Salish Sea Live Views</title>

  <meta name="description" content="Live webcam views from coastal locations around the Salish Sea, including White Rock Pier Cam and White Rock East Beach." />
  <meta name="keywords" content="Salish Sea webcams, White Rock Pier camera, White Rock East Beach camera, White Rock pier cam, coastal webcams, BC beach webcams, live ocean views, marine webcams" />

  <link rel="canonical" href="https://halibutbank.ca/webcams.html" />
  <link rel="stylesheet" href="/assets/css/style-v4.css?v=20251112" />
  <link rel="stylesheet" href="/assets/css/nav-tide-styles-v4.css" />
  <link rel="stylesheet" href="/assets/css/warning-banner-v4.css" />

  <style>
    .webcam-region {
      margin: 2rem auto;
      max-width: 1200px;
      padding: 0 1rem;
    }

    .webcam-region-header {
      background: linear-gradient(to right, #2c5282, #2b6cb0);
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 8px 8px 0 0;
      margin-bottom: 0;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
    }

    .webcam-region-header:hover {
      background: linear-gradient(to right, #2a4a75, #295fa0);
    }

    .webcam-region-header h2 {
      margin: 0;
      font-size: 1.4rem;
      font-weight: 600;
    }

    .webcam-region-toggle-btn {
      display: inline-block;
      margin-right: 0.5rem;
      font-size: 0.9em;
      transition: transform 0.2s;
    }

    .webcam-region.collapsed .webcam-region-toggle-btn {
      transform: rotate(-90deg);
    }

    .webcam-region-content {
      max-height: 5000px;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }

    .webcam-region.collapsed .webcam-region-content {
      max-height: 0;
    }

    .webcam-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(500px, 1fr));
      gap: 2rem;
      padding: 2rem 0;
      justify-content: center;
    }

    .webcam-card {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      transition: box-shadow 0.2s;
      max-width: 100%;
    }

    .webcam-card:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .webcam-header {
      background: linear-gradient(to right, #004b7c, #005a94);
      color: white;
      padding: 1rem 1.5rem;
    }

    .webcam-header h3 {
      margin: 0 0 0.25rem 0;
      font-size: 1.3rem;
    }

    .webcam-location {
      font-size: 0.9rem;
      opacity: 0.9;
      margin: 0;
    }

    .webcam-image-container {
      position: relative;
      width: 100%;
      max-width: 100%;
      background: #f0f0f0;
      min-height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .webcam-image {
      width: 100%;
      max-width: 100%;
      height: auto;
      display: block;
      object-fit: contain;
    }

    .slideshow-controls {
      display: none; /* Hidden until slideshow data loads */
      padding: 0.75rem;
      background: #f7fafc;
      border-top: 1px solid #e2e8f0;
      align-items: center;
      justify-content: center;
      gap: 1rem;
    }

    .slideshow-nav {
      background: #4299e1;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      cursor: pointer;
      font-size: 1.2rem;
      border-radius: 4px;
      transition: background 0.2s, opacity 0.2s;
      min-width: 40px;
    }

    .slideshow-nav:hover:not(:disabled) {
      background: #3182ce;
    }

    .slideshow-nav:disabled {
      opacity: 0.3;
      cursor: not-allowed;
      background: #cbd5e0;
    }

    .slideshow-dots {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .slideshow-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #cbd5e0;
      border: none;
      cursor: pointer;
      transition: background 0.2s, transform 0.2s;
    }

    .slideshow-dot:hover {
      transform: scale(1.2);
    }

    .slideshow-dot.active {
      background: #4299e1;
    }

    .webcam-loading {
      color: #718096;
      font-style: italic;
    }

    .webcam-info {
      padding: 1rem 1.5rem;
      background: #f7fafc;
    }

    .webcam-update-notice {
      font-size: 0.9rem;
      color: #2c5282;
      background: #e6f2ff;
      padding: 0.5rem;
      margin-bottom: 0.75rem;
      border-radius: 4px;
      text-align: center;
      font-weight: 500;
    }

    .webcam-timestamp {
      font-size: 0.85rem;
      color: #4a5568;
      margin-bottom: 0.5rem;
    }

    .slideshow-age-indicator {
      font-size: 0.8rem;
      color: #718096;
      font-style: italic;
      margin-top: 0.25rem;
    }

    .webcam-source {
      font-size: 0.85rem;
      color: #4a5568;
    }

    .webcam-source a {
      color: #4299e1;
      text-decoration: none;
    }

    .webcam-source a:hover {
      text-decoration: underline;
    }

    .marine-conditions-banner {
      background: white;
      padding: 1.25rem 1.5rem;
      margin: 0 auto 1.5rem auto;
      max-width: 1200px;
      border-radius: 6px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      border: 1px solid #e2e8f0;
    }

    .marine-conditions-banner h3 {
      margin: 0 0 0.75rem 0;
      font-size: 1.1rem;
      font-weight: 600;
      color: #2c5282;
    }

    .conditions-stack {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .condition-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.5rem 0;
      border-bottom: 1px solid #f0f0f0;
    }

    .condition-row:last-child {
      border-bottom: none;
    }

    .condition-station-name {
      font-size: 0.9rem;
      font-weight: 600;
      color: #4a5568;
      min-width: 160px;
      flex-shrink: 0;
    }

    .condition-data {
      display: flex;
      align-items: flex-start;
      gap: 1.5rem;
      flex-wrap: wrap;
      flex: 1;
    }

    .condition-section {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .condition-section-label {
      font-size: 0.75rem;
      font-weight: 600;
      color: #718096;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .condition-timestamp {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-left: auto;
      white-space: nowrap;
    }

    .condition-actions {
      display: flex;
      gap: 0.5rem;
      margin-left: 0.5rem;
    }

    .condition-link {
      font-size: 0.85rem;
      color: #0077be;
      text-decoration: none;
      padding: 0.25rem 0.5rem;
      border-radius: 3px;
      transition: background 0.2s;
    }

    .condition-link:hover {
      background: #e6f2ff;
      text-decoration: underline;
    }

    .condition-wind,
    .condition-waves {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .condition-wind-arrow {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
    }

    .condition-wind-details {
      display: flex;
      align-items: baseline;
      gap: 0.35rem;
    }

    .wind-cardinal {
      font-weight: 600;
      color: #2c5282;
    }

    .wind-degrees {
      color: #718096;
      font-size: 0.9rem;
    }

    .wind-speed {
      font-weight: 600;
      color: #2c5282;
    }

    .wind-gust {
      color: #718096;
    }

    .wave-icon {
      font-size: 1.1rem;
    }

    .wave-details {
      display: flex;
      align-items: baseline;
      gap: 0.35rem;
    }

    .wave-height {
      font-weight: 600;
      color: #2c5282;
    }

    .wave-period {
      color: #718096;
    }

    .wave-details-extended {
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
    }

    .wave-icon-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
    }

    .wave-arrow-container {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
    }

    .wave-data-grid {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .wave-metric {
      display: flex;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .wave-label {
      font-weight: 600;
      color: #4a5568;
      min-width: 48px;
    }

    .wave-value {
      color: #2c5282;
      font-weight: 500;
    }

    @media (max-width: 768px) {
      .condition-row {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
      }

      .condition-station-name {
        min-width: auto;
      }
    }

    .refresh-button {
      display: inline-block;
      padding: 0.5rem 1rem;
      background: #4299e1;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      margin-top: 0.5rem;
      transition: background 0.2s;
    }

    .refresh-button:hover {
      background: #3182ce;
    }

    .webcam-error {
      padding: 1rem;
      background: #fff5f5;
      color: #c53030;
      border-radius: 4px;
      margin: 1rem;
      text-align: center;
    }

    /* Mobile and tablet responsive */
    @media (max-width: 1024px) {
      .webcam-grid {
        grid-template-columns: 1fr;
        padding: 0 0.5rem;
      }
    }

    @media (max-width: 768px) {
      .webcam-region {
        margin: 1rem auto;
        padding: 0 0.5rem;
      }

      .webcam-region-header {
        padding: 0.75rem 1rem;
      }

      .webcam-region-header h2 {
        font-size: 1.1rem;
      }

      .webcam-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
        padding: 1rem 0;
      }

      .webcam-card {
        border-radius: 6px;
      }

      .webcam-header {
        padding: 0.75rem 1rem;
      }

      .webcam-header h3 {
        font-size: 1.1rem;
      }

      .webcam-image-container {
        min-height: 180px;
      }

      .webcam-info {
        padding: 0.75rem 1rem;
      }

      .webcam-update-notice {
        font-size: 0.8rem;
        padding: 0.4rem;
        margin-bottom: 0.5rem;
      }

      .slideshow-controls {
        padding: 0.5rem;
        gap: 0.5rem;
      }

      .slideshow-nav {
        padding: 0.4rem 0.75rem;
        font-size: 1rem;
        min-width: 36px;
      }

      .slideshow-dot {
        width: 10px;
        height: 10px;
      }

      .marine-conditions-banner {
        padding: 0.75rem 1rem;
        margin: 0 0 1rem 0;
      }

      .marine-conditions-banner h3 {
        font-size: 0.95rem;
        margin-bottom: 0.5rem;
      }

      .conditions-stack {
        gap: 0.5rem;
      }

      .condition-row {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.25rem;
        padding: 0.4rem 0;
      }

      .condition-station-name {
        font-size: 0.85rem;
        min-width: auto;
      }

      .condition-data {
        gap: 0.75rem;
      }

      .condition-timestamp {
        margin-left: 0;
        font-size: 0.75rem;
      }

      /* Collapsible intro sections on mobile */
      .intro-section {
        margin-bottom: 1rem !important;
        padding: 0.75rem 1rem !important;
      }

      .intro-section h2 {
        font-size: 1rem !important;
        cursor: pointer;
      }

      .intro-section.collapsed .intro-content {
        display: none;
      }

      .intro-section h2::after {
        content: ' â–¼';
        font-size: 0.7em;
        opacity: 0.7;
      }

      .intro-section.collapsed h2::after {
        content: ' â–¶';
      }

      .refresh-button {
        padding: 0.4rem 0.75rem;
        font-size: 0.85rem;
      }
    }

    @media (max-width: 480px) {
      .webcam-region {
        margin: 0.75rem auto;
        padding: 0 0.25rem;
      }

      .webcam-grid {
        gap: 0.75rem;
        padding: 0.75rem 0;
      }

      .webcam-header {
        padding: 0.6rem 0.75rem;
      }

      .webcam-header h3 {
        font-size: 1rem;
      }

      .webcam-location {
        font-size: 0.8rem;
      }

      .webcam-info {
        padding: 0.6rem 0.75rem;
      }

      .condition-section-label {
        font-size: 0.7rem;
      }
    }
  </style>
</head>
<body>
  <!-- Warning banners container -->
  <div hx-get="/components/warning-banner.html?v=1" hx-trigger="load" hx-swap="outerHTML swap:0ms settle:0ms"></div>

  <div hx-get="/components/nav.html?v=1" hx-trigger="load" hx-swap="outerHTML swap:0ms settle:0ms" style="min-height: 60px;"></div>

  <div hx-get="/components/header-webcams.html?v=1" hx-trigger="load" hx-swap="outerHTML swap:0ms settle:0ms" style="min-height: 80px;"></div>

  <div hx-get="/components/tagline-webcams.html?v=1" hx-trigger="load" hx-swap="outerHTML swap:0ms settle:0ms" style="min-height: 40px;"></div>

  <div class="container">
    <section class="intro-section collapsed" style="background: #edf2f7; padding: 1rem; border-radius: 6px; margin-bottom: 1rem;">
      <h2 onclick="this.parentElement.classList.toggle('collapsed')" style="margin: 0; color: #2c5282; font-size: 1.1rem; cursor: pointer;">About Coastal Webcams</h2>
      <div class="intro-content" style="margin-top: 0.75rem;">
        <p style="margin: 0 0 0.5rem 0; font-size: 0.9rem;">
          Recent views from coastal webcams around the Salish Sea. Images update every 10-30 minutes.
        </p>
        <p style="margin: 0; font-size: 0.85rem; color: #4a5568;">
          <strong>Note:</strong> Screen grabs have stream delay. Click "View Source" for live video.
        </p>
      </div>
    </section>

    <!-- Additional Webcam Resources - collapsed by default on mobile -->
    <section class="intro-section collapsed" style="background: white; padding: 1rem; border-radius: 6px; margin-bottom: 1rem; border: 1px solid #e0e7ee;">
      <h2 onclick="this.parentElement.classList.toggle('collapsed')" style="margin: 0; color: #2c5282; font-size: 1rem; cursor: pointer;">More Webcams</h2>
      <div class="intro-content" style="margin-top: 0.75rem; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 0.5rem; font-size: 0.85rem;">
        <a href="https://www.pointrobertsmarina.com/webcams/" target="_blank" rel="noopener" style="color: #4299e1;">Point Roberts Marina â†—</a>
        <a href="https://birchbaywa.org/webcam/" target="_blank" rel="noopener" style="color: #4299e1;">Birch Bay â†—</a>
        <a href="https://www.hollyburnsailingclub.ca/webcam" target="_blank" rel="noopener" style="color: #4299e1;">Ambleside (Hollyburn SC) â†—</a>
        <a href="http://www.boundarybayweather.com/" target="_blank" rel="noopener" style="color: #4299e1;">Boundary Bay â†—</a>
        <a href="https://www.kiteboardbc.com/webcam/jericho/" target="_blank" rel="noopener" style="color: #4299e1;">Jericho (KiteboardBC) â†—</a>
        <a href="https://jsca.bc.ca/services/steamcam-ptz/" target="_blank" rel="noopener" style="color: #4299e1;">Jericho (JSCA HD) â†—</a>
        <a href="https://www.youtube.com/watch?v=eCcF7epO2T8" target="_blank" rel="noopener" style="color: #4299e1;">Chesterman Beach â†—</a>
        <a href="https://oceanvillageresort.com/beach-cam/" target="_blank" rel="noopener" style="color: #4299e1;">Mackenzie Beach â†—</a>
      </div>
    </section>

    <div id="webcams-container">
      <!-- Webcam regions will be loaded here -->
    </div>
  </div>

  <!-- About Section -->
  <div hx-get="/components/about-generic.html?v=1" hx-trigger="load" hx-swap="outerHTML"></div>

  <!-- Navigation (Bottom) -->
  <div hx-get="/components/nav.html?v=1" hx-trigger="load" hx-swap="outerHTML"></div>

  <div hx-get="/components/footer.html?v=1" hx-trigger="load" hx-swap="outerHTML"></div>

  <script src="/assets/js/warning-banner.js"></script>
  <script>
    // Webcam configuration with regional grouping
    const webcamRegions = {
      'english_bay': {
        name: 'English Bay - Vancouver'
      },
      'salish_sea_south': {
        name: 'Salish Sea - Boundary Bay - White Rock'
      },
      'west_coast_vi': {
        name: 'West Coast Vancouver Island (Tofino)'
      }
    };

    const webcams = [
      {
        id: 'englishbay',
        region: 'english_bay',
        name: 'Ambleside Beach / English Bay',
        location: 'West Vancouver, BC',
        dataUrl: '/data/englishbay/latest.json',
        imageUrl: '/data/englishbay/latest.jpg',
        slideshowUrl: '/data/englishbay/slideshow_manifest.json',
        slideshowPath: '/data/englishbay/',
        updateInterval: 20,  // minutes
        streamDelay: null,  // direct image, minimal delay
        attribution: {
          text: 'Webcam provided by Hollyburn Sailing Club',
          url: 'https://www.hollyburnsailingclub.ca/',
          logo: null
        },
        conditions: [
          {
            label: 'English Bay Buoy',
            buoyStation: '4600304',
            fields: ['wind', 'waves']
          },
          {
            label: 'Jericho Sailing Centre',
            windStation: 'JERICHO',
            fields: ['wind']
          }
        ]
      },
      {
        id: 'whiterock',
        region: 'salish_sea_south',
        name: 'White Rock Pier Cam',
        location: 'White Rock, BC',
        dataUrl: '/data/wrcam/latest.json',
        imageUrl: '/data/wrcam/latest.jpg',
        slideshowUrl: '/data/wrcam/slideshow_manifest.json',
        slideshowPath: '/data/wrcam/',
        updateInterval: 10,  // minutes
        streamDelay: 6,  // minutes
        conditions: [
          {
            label: 'White Rock East Beach',
            customStation: 'whiterock_east',
            fields: ['wind_speed_only']
          },
          {
            label: 'Crescent Pile',
            buoyStation: 'CRPILE',
            fields: ['wind', 'waves']
          }
        ]
      },
      {
        id: 'boundarybay',
        region: 'salish_sea_south',
        name: 'White Rock East Beach',
        location: 'White Rock, BC',
        dataUrl: '/data/bbcam/latest.json',
        imageUrl: '/data/bbcam/latest.jpg',
        slideshowUrl: '/data/bbcam/slideshow_manifest.json',
        slideshowPath: '/data/bbcam/',
        updateInterval: 10,  // minutes
        streamDelay: 20,  // minutes
        downNotice: 'âš ï¸ YouTube livestream temporarily unavailable. Images shown are from last successful capture.',  // Temporary downtime notice
        conditions: [
          {
            label: 'White Rock East Beach',
            customStation: 'whiterock_east',
            fields: ['wind_speed_only']
          },
          {
            label: 'Crescent Pile',
            buoyStation: 'CRPILE',
            fields: ['wind', 'waves']
          }
        ]
      },
      {
        id: 'mudbay',
        region: 'salish_sea_south',
        name: 'Mud Bay HD',
        location: 'South Surrey, BC',
        dataUrl: '/data/mudbay/latest.json',
        imageUrl: '/data/mudbay/latest.jpg',
        slideshowUrl: '/data/mudbay/slideshow_manifest.json',
        slideshowPath: '/data/mudbay/',
        updateInterval: 30,  // minutes
        streamDelay: null,  // unknown (direct image URL from construction cam)
        conditions: [
          {
            label: 'White Rock East Beach',
            customStation: 'whiterock_east',
            fields: ['wind_speed_only']
          },
          {
            label: 'Crescent Pile',
            buoyStation: 'CRPILE',
            fields: ['wind', 'waves']
          }
        ]
      },
      {
        id: 'coxbay',
        region: 'west_coast_vi',
        name: 'Cox Bay',
        location: 'Tofino, BC',
        dataUrl: '/data/coxbay/latest.json',
        imageUrl: '/data/coxbay/latest.jpg',
        slideshowUrl: '/data/coxbay/slideshow_manifest.json',
        slideshowPath: '/data/coxbay/',
        updateInterval: 10,  // minutes
        streamDelay: 20,  // minutes
        conditions: [
          {
            label: 'La Perouse Bank',
            buoyStation: '4600206',
            fields: ['wind', 'waves_detailed']
          }
        ]
      }
    ];

    // Format timestamp for display (24-hour format)
    function formatTimestamp(isoString) {
      const date = new Date(isoString);
      const options = {
        timeZone: 'America/Vancouver',
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false,
        timeZoneName: 'short'
      };
      return date.toLocaleString('en-US', options);
    }

    // Format short timestamp for conditions display
    function formatShortTimestamp(isoString) {
      const date = new Date(isoString);
      const options = {
        timeZone: 'America/Vancouver',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
      };
      return date.toLocaleString('en-US', options);
    }

    // Fetch marine data (buoy, wind, and custom stations)
    let cachedMarineData = null;
    async function fetchMarineData() {
      if (cachedMarineData) return cachedMarineData;

      try {
        const [buoyResponse, windResponse, whiterockResponse] = await Promise.all([
          fetch('/data/latest_buoy_v2.json'),
          fetch('/data/latest_wind.json'),
          fetch('/data/whiterock_weather.json')
        ]);

        const buoyData = buoyResponse.ok ? await buoyResponse.json() : {};
        const windData = windResponse.ok ? await windResponse.json() : {};
        const whiterockData = whiterockResponse.ok ? await whiterockResponse.json() : null;

        cachedMarineData = {
          buoy: buoyData,
          wind: windData,
          custom: {
            whiterock_east: whiterockData
          }
        };
        return cachedMarineData;
      } catch (error) {
        console.error('Failed to fetch marine data:', error);
        return { buoy: {}, wind: {}, custom: {} };
      }
    }

    // Create wind direction arrow SVG
    function createWindArrow(degrees) {
      // Arrow points where wind is blowing TO (meteorological convention)
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', '20');
      svg.setAttribute('height', '20');
      svg.setAttribute('viewBox', '-6 -10 12 24');
      svg.style.transform = `rotate(${degrees}deg)`;

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', 'M0,12 L-5,-8 L0,-5 L5,-8 Z');
      path.setAttribute('fill', '#dc2626');
      path.setAttribute('stroke', '#dc2626');
      path.setAttribute('stroke-width', '1.5');

      svg.appendChild(path);
      return svg;
    }

    // Create wave direction arrow SVG (different color from wind)
    function createWaveArrow(degrees) {
      // Arrow points where waves are coming FROM (oceanographic convention)
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', '20');
      svg.setAttribute('height', '20');
      svg.setAttribute('viewBox', '-6 -10 12 24');
      svg.style.transform = `rotate(${degrees}deg)`;

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', 'M0,12 L-5,-8 L0,-5 L5,-8 Z');
      path.setAttribute('fill', '#2563eb');
      path.setAttribute('stroke', '#2563eb');
      path.setAttribute('stroke-width', '1.5');

      svg.appendChild(path);
      return svg;
    }

    // Create angular spread vector visualization
    // Shows main direction arrow with smaller arrows indicating directional spread
    function createAngularSpreadVector(avgDirection, spread, size = 70) {
      if (avgDirection == null || spread == null) return null;

      const halfSpread = spread / 2;
      const minDir = avgDirection - halfSpread;
      const maxDir = avgDirection + halfSpread;

      // Center point
      const cx = size / 2;
      const cy = size / 2;
      const radius = size * 0.42;

      // Match the existing getDirectionalArrow rotation convention:
      // Base arrow points DOWN (towards south), then rotate by degrees
      const mainRot = avgDirection;
      const minRot = minDir;
      const maxRot = maxDir;

      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', size);
      svg.setAttribute('height', size);
      svg.setAttribute('viewBox', `0 0 ${size} ${size}`);
      svg.style.display = 'inline-block';
      svg.style.verticalAlign = 'middle';
      svg.style.marginLeft = '0.5rem';

      // Background circle
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', cx);
      circle.setAttribute('cy', cy);
      circle.setAttribute('r', radius + 2);
      circle.setAttribute('fill', 'none');
      circle.setAttribute('stroke', '#e0e7ee');
      circle.setAttribute('stroke-width', '1');
      svg.appendChild(circle);

      // Create spread sector arc
      // Add 180Â° to show TRAVEL directions (matching arrow), not source directions
      const startAngleSVG = (minRot + 180) - 90;
      const endAngleSVG = (maxRot + 180) - 90;
      const startAngleRad = startAngleSVG * Math.PI / 180;
      const endAngleRad = endAngleSVG * Math.PI / 180;
      const arcRadius = radius + 2; // Extend to circle edge

      const x1 = cx + arcRadius * Math.cos(startAngleRad);
      const y1 = cy + arcRadius * Math.sin(startAngleRad);
      const x2 = cx + arcRadius * Math.cos(endAngleRad);
      const y2 = cy + arcRadius * Math.sin(endAngleRad);

      const largeArc = spread > 180 ? 1 : 0;

      const arcPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      arcPath.setAttribute('d', `M ${cx},${cy} L ${x1},${y1} A ${arcRadius},${arcRadius} 0 ${largeArc},1 ${x2},${y2} Z`);
      arcPath.setAttribute('fill', 'rgba(30, 136, 229, 0.15)');
      arcPath.setAttribute('stroke', 'rgba(30, 136, 229, 0.3)');
      arcPath.setAttribute('stroke-width', '1');
      svg.appendChild(arcPath);

      // Create main direction arrow
      const arrowGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      arrowGroup.setAttribute('transform', `rotate(${mainRot} ${cx} ${cy})`);

      // Arrow shaft
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', cx);
      line.setAttribute('y1', cy - radius + 8);
      line.setAttribute('x2', cx);
      line.setAttribute('y2', cy + radius - 3);
      line.setAttribute('stroke', '#1e88e5');
      line.setAttribute('stroke-width', '2.5');
      arrowGroup.appendChild(line);

      // Triangular arrowhead
      const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      arrowHead.setAttribute('d', `M${cx},${cy + radius + 2} L${cx - 5},${cy + radius - 8} L${cx + 5},${cy + radius - 8} Z`);
      arrowHead.setAttribute('fill', '#1e88e5');
      arrowGroup.appendChild(arrowHead);

      svg.appendChild(arrowGroup);

      // Cardinal directions
      function createText(x, y, text) {
        const textElem = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        textElem.setAttribute('x', x);
        textElem.setAttribute('y', y);
        textElem.setAttribute('text-anchor', 'middle');
        textElem.setAttribute('font-size', '8');
        textElem.setAttribute('fill', '#999');
        textElem.textContent = text;
        return textElem;
      }

      svg.appendChild(createText(cx, 8, 'N'));
      svg.appendChild(createText(size - 6, cy + 3, 'E'));
      svg.appendChild(createText(cx, size - 2, 'S'));
      svg.appendChild(createText(6, cy + 3, 'W'));

      return svg;
    }

    // Create marine conditions banner (before webcam cards)
    function createConditionsBanner(marineData) {
      if (!marineData) return null;

      const banner = document.createElement('div');
      banner.className = 'marine-conditions-banner';
      banner.id = 'marine-conditions-banner';

      const title = document.createElement('h3');
      title.textContent = 'Current Marine Conditions';
      banner.appendChild(title);

      const stack = document.createElement('div');
      stack.className = 'conditions-stack';

      // White Rock East Beach (on-shore wind)
      const whiterockData = marineData.custom?.whiterock_east;
      if (whiterockData && !whiterockData.stale && whiterockData.wind_speed !== null) {
        const row = document.createElement('div');
        row.className = 'condition-row';

        const stationName = document.createElement('div');
        stationName.className = 'condition-station-name';
        stationName.textContent = 'White Rock East Beach';
        row.appendChild(stationName);

        const dataDiv = document.createElement('div');
        dataDiv.className = 'condition-data';

        const windDiv = document.createElement('div');
        windDiv.className = 'condition-wind';

        const arrow = document.createElement('span');
        arrow.className = 'condition-wind-arrow';
        arrow.appendChild(createWindArrow(whiterockData.wind_direction));
        windDiv.appendChild(arrow);

        const windDetails = document.createElement('div');
        windDetails.className = 'condition-wind-details';
        windDetails.innerHTML = `
          <span class="wind-cardinal">${whiterockData.wind_direction_cardinal || ''}</span>
          <span class="wind-degrees">(${Math.round(whiterockData.wind_direction)}Â°)</span>
          <span class="wind-speed">${whiterockData.wind_speed.toFixed(0)}</span>
          ${whiterockData.wind_gust ? `<span class="wind-gust">G ${whiterockData.wind_gust.toFixed(0)}</span>` : ''}
          <span class="wind-gust">kt</span>
        `;
        windDiv.appendChild(windDetails);
        dataDiv.appendChild(windDiv);

        // Timestamp
        if (whiterockData.observation_time) {
          const timestamp = document.createElement('div');
          timestamp.className = 'condition-timestamp';
          timestamp.textContent = formatShortTimestamp(whiterockData.observation_time);
          dataDiv.appendChild(timestamp);
        }

        // Action links
        const actions = document.createElement('div');
        actions.className = 'condition-actions';
        actions.innerHTML = `
          <a href="https://maps.whiterockcity.ca/weather/" target="_blank" class="condition-link">View Data</a>
        `;
        dataDiv.appendChild(actions);

        row.appendChild(dataDiv);
        stack.appendChild(row);
      }

      // Crescent Pile (offshore wind + waves)
      const crpileData = marineData.buoy?.CRPILE;
      if (crpileData && !crpileData.stale) {
        const row = document.createElement('div');
        row.className = 'condition-row';

        const stationName = document.createElement('div');
        stationName.className = 'condition-station-name';
        stationName.textContent = 'Crescent Pile';
        row.appendChild(stationName);

        const dataDiv = document.createElement('div');
        dataDiv.className = 'condition-data';

        // Wind
        if (crpileData.wind_speed !== null && crpileData.wind_direction !== null) {
          const windDiv = document.createElement('div');
          windDiv.className = 'condition-wind';

          const arrow = document.createElement('span');
          arrow.className = 'condition-wind-arrow';
          arrow.appendChild(createWindArrow(crpileData.wind_direction));
          windDiv.appendChild(arrow);

          const windDetails = document.createElement('div');
          windDetails.className = 'condition-wind-details';
          windDetails.innerHTML = `
            <span class="wind-cardinal">${crpileData.wind_direction_cardinal || ''}</span>
            <span class="wind-degrees">(${Math.round(crpileData.wind_direction)}Â°)</span>
            <span class="wind-speed">${crpileData.wind_speed.toFixed(0)}</span>
            ${crpileData.wind_gust ? `<span class="wind-gust">G ${crpileData.wind_gust.toFixed(0)}</span>` : ''}
            <span class="wind-gust">kt</span>
          `;
          windDiv.appendChild(windDetails);
          dataDiv.appendChild(windDiv);
        }

        // Waves
        if (crpileData.wave_height_sig !== null && crpileData.wave_period_avg !== null) {
          const waveDiv = document.createElement('div');
          waveDiv.className = 'condition-waves';
          waveDiv.innerHTML = `
            <span class="wave-icon">ðŸŒŠ</span>
            <div class="wave-details">
              <span class="wave-height">${crpileData.wave_height_sig.toFixed(2)}m</span>
              <span class="wave-period">@ ${crpileData.wave_period_avg.toFixed(1)}s</span>
            </div>
          `;
          dataDiv.appendChild(waveDiv);
        }

        // Timestamp
        if (crpileData.observation_time) {
          const timestamp = document.createElement('div');
          timestamp.className = 'condition-timestamp';
          timestamp.textContent = formatShortTimestamp(crpileData.observation_time);
          dataDiv.appendChild(timestamp);
        }

        // Action links
        const actions = document.createElement('div');
        actions.className = 'condition-actions';
        actions.innerHTML = `
          <a href="/charts.html#CRPILE" class="condition-link">Show on Map</a>
          <a href="/charts.html?station=CRPILE" class="condition-link">View Charts</a>
        `;
        dataDiv.appendChild(actions);

        row.appendChild(dataDiv);
        stack.appendChild(row);
      }

      banner.appendChild(stack);

      // Only return if we have any rows
      return stack.children.length > 0 ? banner : null;
    }

    // Create regional marine conditions section
    function createRegionConditions(regionWebcams, marineData) {
      if (!marineData) return null;

      // Collect all unique condition sources from this region's webcams
      const conditionSources = new Map();

      regionWebcams.forEach(webcam => {
        if (webcam.conditions) {
          webcam.conditions.forEach(condition => {
            const key = condition.buoyStation || condition.customStation || condition.windStation;
            if (key && !conditionSources.has(key)) {
              conditionSources.set(key, condition);
            }
          });
        }
      });

      if (conditionSources.size === 0) return null;

      const conditionsSection = document.createElement('div');
      conditionsSection.className = 'marine-conditions-banner';
      conditionsSection.style.margin = '0 0 1.5rem 0';

      const title = document.createElement('h3');
      title.textContent = 'Current Marine Conditions';
      title.style.fontSize = '1.1rem';
      conditionsSection.appendChild(title);

      const stack = document.createElement('div');
      stack.className = 'conditions-stack';

      conditionSources.forEach((condition, key) => {
        let data = null;

        if (condition.buoyStation) {
          data = marineData.buoy?.[condition.buoyStation];
        } else if (condition.customStation) {
          data = marineData.custom?.[condition.customStation];
        } else if (condition.windStation) {
          data = marineData.wind?.[condition.windStation];
        }

        if (!data || data.stale) return;

        const row = document.createElement('div');
        row.className = 'condition-row';

        const stationName = document.createElement('div');
        stationName.className = 'condition-station-name';
        stationName.textContent = condition.label;
        row.appendChild(stationName);

        const dataDiv = document.createElement('div');
        dataDiv.className = 'condition-data';

        // Wind section - handle both buoy (wind_speed) and wind station (wind_speed_kt) formats
        const windSpeed = data.wind_speed ?? data.wind_speed_kt;
        const windGust = data.wind_gust ?? data.wind_gust_kt;
        if (windSpeed !== null && windSpeed !== undefined && data.wind_direction !== null) {
          const windSection = document.createElement('div');
          windSection.className = 'condition-section';

          const windLabel = document.createElement('div');
          windLabel.className = 'condition-section-label';
          windLabel.textContent = 'Wind:';
          windSection.appendChild(windLabel);

          const windDiv = document.createElement('div');
          windDiv.className = 'condition-wind';

          const arrow = document.createElement('span');
          arrow.className = 'condition-wind-arrow';
          arrow.appendChild(createWindArrow(data.wind_direction));
          windDiv.appendChild(arrow);

          const windDetails = document.createElement('div');
          windDetails.className = 'condition-wind-details';
          windDetails.innerHTML = `
            <span class="wind-cardinal">${data.wind_direction_cardinal || ''}</span>
            <span class="wind-degrees">(${Math.round(data.wind_direction)}Â°)</span>
            <span class="wind-speed">${windSpeed.toFixed(0)}</span>
            ${windGust ? `<span class="wind-gust">G ${windGust.toFixed(0)}</span>` : ''}
            <span class="wind-gust">kt</span>
          `;
          windDiv.appendChild(windDetails);
          windSection.appendChild(windDiv);
          dataDiv.appendChild(windSection);
        }

        // Waves section (if available) - check if detailed wave data is requested
        const showDetailedWaves = condition.fields?.includes('waves_detailed');

        if (data.wave_height_sig !== null && data.wave_height_sig !== undefined) {
          const waveSection = document.createElement('div');
          waveSection.className = 'condition-section';

          const waveLabel = document.createElement('div');
          waveLabel.className = 'condition-section-label';
          waveLabel.textContent = 'Waves:';
          waveSection.appendChild(waveLabel);

          const waveDiv = document.createElement('div');
          waveDiv.className = 'condition-waves';

          if (showDetailedWaves) {
            // Detailed wave display for Environment Canada buoys
            const waveDetails = document.createElement('div');
            waveDetails.className = 'wave-details-extended';

            // Wave icon and arrow for direction
            const iconSection = document.createElement('div');
            iconSection.className = 'wave-icon-section';
            iconSection.innerHTML = '<span class="wave-icon">ðŸŒŠ</span>';

            if (data.wave_direction_peak !== null && data.wave_direction_peak !== undefined) {
              const arrowContainer = document.createElement('span');
              arrowContainer.className = 'wave-arrow-container';
              arrowContainer.appendChild(createWaveArrow(data.wave_direction_peak));
              iconSection.appendChild(arrowContainer);
            }

            waveDetails.appendChild(iconSection);

            // Wave data grid
            const dataGrid = document.createElement('div');
            dataGrid.className = 'wave-data-grid';

            // Significant wave height and period
            const sigMetric = document.createElement('div');
            sigMetric.className = 'wave-metric';
            sigMetric.innerHTML = `<span class="wave-label">Sig:</span> <span class="wave-value">${data.wave_height_sig.toFixed(1)}m @ ${data.wave_period_sig ? data.wave_period_sig.toFixed(1) + 's' : 'N/A'}</span>`;
            dataGrid.appendChild(sigMetric);

            // Peak wave height and period
            if (data.wave_height_max !== null && data.wave_height_max !== undefined) {
              const peakMetric = document.createElement('div');
              peakMetric.className = 'wave-metric';
              peakMetric.innerHTML = `<span class="wave-label">Peak:</span> <span class="wave-value">${data.wave_height_max.toFixed(1)}m @ ${data.wave_period_peak ? data.wave_period_peak.toFixed(1) + 's' : 'N/A'}</span>`;
              dataGrid.appendChild(peakMetric);
            }

            // Wave direction with spread
            if (data.wave_direction_peak !== null && data.wave_direction_peak !== undefined) {
              const dirMetric = document.createElement('div');
              dirMetric.className = 'wave-metric';
              const dirCardinal = data.wave_direction_peak_cardinal || '';
              dirMetric.innerHTML = `<span class="wave-label">Dir:</span> <span class="wave-value">${dirCardinal} (${Math.round(data.wave_direction_peak)}Â°)</span>`;
              dataGrid.appendChild(dirMetric);

              // Wave spread - show both peak and average with quality labels
              if (data.wave_direction_spread_peak !== null && data.wave_direction_spread_peak !== undefined) {
                // Peak spread with quality description
                const peakSpread = data.wave_direction_spread_peak;
                let peakDesc = '';
                let peakColor = '#666';
                if (peakSpread < 25) {
                  peakDesc = 'very organized';
                  peakColor = '#38a169';
                } else if (peakSpread < 35) {
                  peakDesc = 'organized';
                  peakColor = '#48bb78';
                } else if (peakSpread < 45) {
                  peakDesc = 'moderate';
                  peakColor = '#d69e2e';
                } else {
                  peakDesc = 'confused';
                  peakColor = '#e53e3e';
                }

                const peakSpreadMetric = document.createElement('div');
                peakSpreadMetric.className = 'wave-metric';
                peakSpreadMetric.style.gridColumn = 'span 2';
                peakSpreadMetric.innerHTML = `<span class="wave-label">Peak Spread:</span> <span class="wave-value">${Math.round(peakSpread)}Â° <span style="color: ${peakColor}; font-weight: 600;">(${peakDesc})</span> <span style="font-size: 0.85em; color: #666;">â€” dominant swell</span></span>`;
                dataGrid.appendChild(peakSpreadMetric);

                // Average spread with quality description (if available)
                if (data.wave_direction_spread_avg !== null && data.wave_direction_spread_avg !== undefined) {
                  const avgSpread = data.wave_direction_spread_avg;
                  let avgDesc = '';
                  let avgColor = '#666';
                  if (avgSpread < 30) {
                    avgDesc = 'very clean';
                    avgColor = '#38a169';
                  } else if (avgSpread < 45) {
                    avgDesc = 'clean';
                    avgColor = '#48bb78';
                  } else if (avgSpread < 60) {
                    avgDesc = 'mixed';
                    avgColor = '#d69e2e';
                  } else {
                    avgDesc = 'messy';
                    avgColor = '#e53e3e';
                  }

                  const avgSpreadMetric = document.createElement('div');
                  avgSpreadMetric.className = 'wave-metric';
                  avgSpreadMetric.style.gridColumn = 'span 2';
                  avgSpreadMetric.innerHTML = `<span class="wave-label">Avg Spread:</span> <span class="wave-value">${Math.round(avgSpread)}Â° <span style="color: ${avgColor}; font-weight: 600;">(${avgDesc})</span> <span style="font-size: 0.85em; color: #666;">â€” all frequencies</span></span>`;
                  dataGrid.appendChild(avgSpreadMetric);
                }

                // Add visual angular spread vectors (peak and average)
                const vectorsContainer = document.createElement('div');
                vectorsContainer.className = 'wave-metric';
                vectorsContainer.style.gridColumn = 'span 2';
                vectorsContainer.style.marginTop = '0.5rem';
                vectorsContainer.style.padding = '0.5rem';
                vectorsContainer.style.background = '#f8fafc';
                vectorsContainer.style.borderRadius = '4px';
                vectorsContainer.style.display = 'flex';
                vectorsContainer.style.gap = '1rem';
                vectorsContainer.style.justifyContent = 'center';

                // Peak spread diagram
                const peakVectorContainer = document.createElement('div');
                peakVectorContainer.style.textAlign = 'center';
                const peakVectorSvg = createAngularSpreadVector(data.wave_direction_peak, data.wave_direction_spread_peak, 70);
                if (peakVectorSvg) {
                  const peakLabel = document.createElement('div');
                  peakLabel.style.fontSize = '0.75em';
                  peakLabel.style.color = '#666';
                  peakLabel.style.marginBottom = '0.25rem';
                  peakLabel.style.fontWeight = '600';
                  peakLabel.textContent = 'Peak Spread';
                  peakVectorContainer.appendChild(peakLabel);
                  peakVectorContainer.appendChild(peakVectorSvg);

                  const peakCaption = document.createElement('div');
                  peakCaption.style.fontSize = '0.7em';
                  peakCaption.style.color = '#999';
                  peakCaption.style.marginTop = '0.25rem';
                  peakCaption.textContent = 'Dominant swell';
                  peakVectorContainer.appendChild(peakCaption);

                  vectorsContainer.appendChild(peakVectorContainer);
                }

                // Average spread diagram (if available)
                if (data.wave_direction_spread_avg !== null && data.wave_direction_spread_avg !== undefined) {
                  const avgVectorContainer = document.createElement('div');
                  avgVectorContainer.style.textAlign = 'center';
                  const avgVectorSvg = createAngularSpreadVector(data.wave_direction_peak, data.wave_direction_spread_avg, 70);
                  if (avgVectorSvg) {
                    const avgLabel = document.createElement('div');
                    avgLabel.style.fontSize = '0.75em';
                    avgLabel.style.color = '#666';
                    avgLabel.style.marginBottom = '0.25rem';
                    avgLabel.style.fontWeight = '600';
                    avgLabel.textContent = 'Average Spread';
                    avgVectorContainer.appendChild(avgLabel);
                    avgVectorContainer.appendChild(avgVectorSvg);

                    const avgCaption = document.createElement('div');
                    avgCaption.style.fontSize = '0.7em';
                    avgCaption.style.color = '#999';
                    avgCaption.style.marginTop = '0.25rem';
                    avgCaption.textContent = 'All frequencies';
                    avgVectorContainer.appendChild(avgCaption);

                    vectorsContainer.appendChild(avgVectorContainer);
                  }
                }

                dataGrid.appendChild(vectorsContainer);
              }
            }

            waveDetails.appendChild(dataGrid);
            waveDiv.appendChild(waveDetails);
          } else {
            // Simple wave display
            const waveDetails = document.createElement('div');
            waveDetails.className = 'wave-details';
            waveDetails.innerHTML = `
              <span class="wave-height">${data.wave_height_sig.toFixed(1)}m</span>
              ${data.wave_period_avg ? `<span class="wave-period">@ ${data.wave_period_avg.toFixed(1)}s</span>` : ''}
            `;
            waveDiv.appendChild(waveDetails);
          }

          waveSection.appendChild(waveDiv);
          dataDiv.appendChild(waveSection);
        }

        // Timestamp
        if (data.observation_time) {
          const timestamp = document.createElement('div');
          timestamp.className = 'condition-timestamp';
          timestamp.textContent = formatShortTimestamp(data.observation_time);
          dataDiv.appendChild(timestamp);
        }

        row.appendChild(dataDiv);
        stack.appendChild(row);
      });

      if (stack.children.length > 0) {
        conditionsSection.appendChild(stack);
        return conditionsSection;
      }

      return null;
    }

    // Slideshow state (per webcam)
    const slideshowState = {};

    // Create webcam card
    async function createWebcamCard(webcam, metadata) {
      const card = document.createElement('div');
      card.className = 'webcam-card';
      card.id = webcam.id;  // Add ID for anchor linking
      card.dataset.webcamId = webcam.id;

      // Header
      const header = document.createElement('div');
      header.className = 'webcam-header';

      const title = document.createElement('h3');
      title.textContent = webcam.name;

      const location = document.createElement('p');
      location.className = 'webcam-location';
      location.textContent = webcam.location;

      header.appendChild(title);
      header.appendChild(location);
      card.appendChild(header);

      // Image container
      const imageContainer = document.createElement('div');
      imageContainer.className = 'webcam-image-container';

      const image = document.createElement('img');
      image.className = 'webcam-image';
      image.src = webcam.imageUrl + '?t=' + Date.now();
      image.alt = webcam.name + ' webcam view';
      image.loading = 'lazy';

      imageContainer.appendChild(image);
      card.appendChild(imageContainer);

      // Slideshow controls container (below image)
      const controlsContainer = document.createElement('div');
      controlsContainer.className = 'slideshow-controls';

      // Previous button (shows older images)
      const prevBtn = document.createElement('button');
      prevBtn.className = 'slideshow-nav prev';
      prevBtn.innerHTML = 'â€¹';
      prevBtn.onclick = () => navigateSlideshow(webcam.id, 1); // +1 = older (higher index)

      // Dots container
      const dotsContainer = document.createElement('div');
      dotsContainer.className = 'slideshow-dots';

      // Next button (shows newer images)
      const nextBtn = document.createElement('button');
      nextBtn.className = 'slideshow-nav next';
      nextBtn.innerHTML = 'â€º';
      nextBtn.onclick = () => navigateSlideshow(webcam.id, -1); // -1 = newer (lower index)

      controlsContainer.appendChild(prevBtn);
      controlsContainer.appendChild(dotsContainer);
      controlsContainer.appendChild(nextBtn);
      card.appendChild(controlsContainer);

      // Info section
      const info = document.createElement('div');
      info.className = 'webcam-info';

      // Attribution notice (if present) - displayed prominently
      if (webcam.attribution) {
        const attrNotice = document.createElement('div');
        attrNotice.style.cssText = 'background: linear-gradient(to right, #2c5282, #2b6cb0); color: white; padding: 0.75rem 1rem; margin-bottom: 0.75rem; border-radius: 4px; text-align: center; font-weight: 500;';
        if (webcam.attribution.url) {
          attrNotice.innerHTML = `${webcam.attribution.text} &mdash; <a href="${webcam.attribution.url}" target="_blank" rel="noopener" style="color: #90cdf4; text-decoration: underline;">â›µ Visit their website</a>`;
        } else {
          attrNotice.textContent = webcam.attribution.text;
        }
        info.appendChild(attrNotice);
      }

      // Down notice (if present)
      if (webcam.downNotice) {
        const downNotice = document.createElement('div');
        downNotice.className = 'webcam-update-notice';
        downNotice.style.background = '#fff3cd';
        downNotice.style.color = '#856404';
        downNotice.style.borderLeft = '4px solid #ffc107';
        downNotice.textContent = webcam.downNotice;
        info.appendChild(downNotice);
      }

      // Update notice with delay info
      const updateNotice = document.createElement('div');
      updateNotice.className = 'webcam-update-notice';
      const interval = webcam.updateInterval || 10;
      const delayText = webcam.streamDelay === null ? 'unknown delay' : `~${webcam.streamDelay} min stream delay`;
      updateNotice.textContent = `Updated every ${interval} minutes â€¢ ${delayText}`;
      info.appendChild(updateNotice);

      if (metadata) {
        const timestamp = document.createElement('div');
        timestamp.className = 'webcam-timestamp';
        timestamp.textContent = 'Last updated: ' + formatTimestamp(metadata.timestamp);
        info.appendChild(timestamp);

        if (metadata.source || metadata.url) {
          const source = document.createElement('div');
          source.className = 'webcam-source';

          if (metadata.url) {
            const link = document.createElement('a');
            link.href = metadata.url;
            link.target = '_blank';
            link.rel = 'noopener noreferrer';
            link.textContent = metadata.source || 'View Source';
            source.appendChild(document.createTextNode('Source: '));
            source.appendChild(link);
          } else {
            source.textContent = 'Source: ' + metadata.source;
          }

          info.appendChild(source);
        }

        // Show on map link
        const mapLink = document.createElement('div');
        mapLink.style.marginTop = '0.5rem';
        const mapLinkAnchor = document.createElement('a');
        mapLinkAnchor.href = `/?station=${webcam.id}#map-section`;
        mapLinkAnchor.textContent = 'ðŸ“ Show on map';
        mapLinkAnchor.style.color = '#2c5282';
        mapLinkAnchor.style.textDecoration = 'none';
        mapLinkAnchor.style.fontWeight = '600';
        mapLinkAnchor.style.display = 'inline-block';
        mapLinkAnchor.style.padding = '0.5rem 0';
        mapLinkAnchor.onmouseover = function() {
          this.style.textDecoration = 'underline';
        };
        mapLinkAnchor.onmouseout = function() {
          this.style.textDecoration = 'none';
        };
        mapLink.appendChild(mapLinkAnchor);
        info.appendChild(mapLink);

        // Refresh button
        const refreshBtn = document.createElement('button');
        refreshBtn.className = 'refresh-button';
        refreshBtn.textContent = 'Refresh Image';
        refreshBtn.onclick = async () => {
          image.src = webcam.imageUrl + '?t=' + Date.now();
          loadWebcamMetadata(webcam, card);

          // Reset slideshow to newest image and update dots
          const state = slideshowState[webcam.id];
          if (state) {
            state.currentIndex = 0;
            updateSlideshowDisplay(webcam.id);
          }

          // Refresh marine data banner
          cachedMarineData = null;
          const freshMarineData = await fetchMarineData();
          if (freshMarineData) {
            const existingBanner = document.getElementById('marine-conditions-banner');
            const newBanner = createConditionsBanner(freshMarineData);

            if (existingBanner && newBanner) {
              existingBanner.replaceWith(newBanner);
            } else if (!existingBanner && newBanner) {
              const container = document.getElementById('webcams-container');
              container.parentNode.insertBefore(newBanner, container);
            }
          }
        };
        info.appendChild(refreshBtn);
      }

      card.appendChild(info);
      return card;
    }

    // Load metadata for a webcam
    async function loadWebcamMetadata(webcam, card) {
      try {
        const response = await fetch(webcam.dataUrl);
        const metadata = await response.json();

        // Update timestamp if card exists
        if (card) {
          const timestampEl = card.querySelector('.webcam-timestamp');
          if (timestampEl) {
            timestampEl.textContent = 'Last updated: ' + formatTimestamp(metadata.timestamp);
          }
        }

        return metadata;
      } catch (error) {
        console.error('Failed to load metadata for ' + webcam.name + ':', error);
        return null;
      }
    }

    // Load all webcams grouped by region
    async function loadWebcams() {
      const container = document.getElementById('webcams-container');

      if (webcams.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #718096; padding: 2rem;">No webcams currently available.</p>';
        return;
      }

      container.innerHTML = '';

      // Fetch marine data once
      const marineData = await fetchMarineData();

      // Group webcams by region
      const groupedWebcams = {};
      webcams.forEach(webcam => {
        const region = webcam.region || 'other';
        if (!groupedWebcams[region]) {
          groupedWebcams[region] = [];
        }
        groupedWebcams[region].push(webcam);
      });

      // Render each region
      for (const [regionKey, regionWebcams] of Object.entries(groupedWebcams)) {
        const regionInfo = webcamRegions[regionKey];

        // Create region container
        const regionContainer = document.createElement('div');
        regionContainer.className = 'webcam-region';

        // Region header
        if (regionInfo) {
          const regionHeader = document.createElement('div');
          regionHeader.className = 'webcam-region-header';

          const webcamCount = regionWebcams.length;
          const countText = `${webcamCount} webcam${webcamCount !== 1 ? 's' : ''}`;

          regionHeader.innerHTML = `
            <h2><span class="webcam-region-toggle-btn">â–¼</span>${regionInfo.name} <span style="font-size: 0.8em; font-weight: normal; opacity: 0.8;">(${countText})</span></h2>
          `;

          // Add click handler to toggle collapse
          regionHeader.addEventListener('click', () => {
            regionContainer.classList.toggle('collapsed');
          });

          regionContainer.appendChild(regionHeader);
        }

        // Create content wrapper for collapsible content
        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'webcam-region-content';

        // Add regional marine conditions section inside content wrapper
        if (marineData && regionWebcams.length > 0) {
          const regionConditions = createRegionConditions(regionWebcams, marineData);
          if (regionConditions) {
            contentWrapper.appendChild(regionConditions);
          }
        }

        // Webcam grid for this region
        const grid = document.createElement('div');
        grid.className = 'webcam-grid';

        // Track webcams that need slideshow loading (after DOM insertion)
        const webcamsToLoadSlideshow = [];

        for (const webcam of regionWebcams) {
          try {
            const metadata = await loadWebcamMetadata(webcam);
            const card = await createWebcamCard(webcam, metadata);
            grid.appendChild(card);

            // Queue slideshow loading for after DOM insertion
            webcamsToLoadSlideshow.push(webcam);
          } catch (error) {
            console.error('Failed to load webcam ' + webcam.name + ':', error);

            const errorCard = document.createElement('div');
            errorCard.className = 'webcam-card';
            errorCard.innerHTML = `
              <div class="webcam-header">
                <h3>${webcam.name}</h3>
                <p class="webcam-location">${webcam.location}</p>
              </div>
              <div class="webcam-error">
                Failed to load webcam data. Please try again later.
              </div>
            `;
            grid.appendChild(errorCard);
          }
        }

        contentWrapper.appendChild(grid);
        regionContainer.appendChild(contentWrapper);
        container.appendChild(regionContainer);

        // Now that cards are in DOM, load slideshows
        webcamsToLoadSlideshow.forEach(webcam => loadSlideshow(webcam));
      }

      // Handle scroll to hash anchor if present (e.g., #whiterock)
      if (window.location.hash) {
        setTimeout(() => {
          const target = document.getElementById(window.location.hash.substring(1));
          if (target) {
            target.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, 300); // Short delay to ensure cards are fully rendered
      }
    }

    // Load slideshow manifest and setup navigation
    async function loadSlideshow(webcam) {
      try {
        const response = await fetch(webcam.slideshowUrl + '?t=' + Date.now());
        if (!response.ok) {
          console.warn('Slideshow not available for ' + webcam.name);
          return;
        }

        const manifest = await response.json();
        if (!manifest || manifest.length === 0) {
          console.warn('No slideshow images for ' + webcam.name);
          return;
        }

        // Store slideshow state
        slideshowState[webcam.id] = {
          images: manifest,
          currentIndex: 0, // Start with newest image
          basePath: webcam.slideshowPath
        };

        // Show navigation controls
        const card = document.querySelector(`[data-webcam-id="${webcam.id}"]`);
        if (card && manifest.length > 1) {
          const controlsContainer = card.querySelector('.slideshow-controls');
          const dotsContainer = card.querySelector('.slideshow-dots');

          controlsContainer.style.display = 'flex';

          // Clear existing dots before creating new ones (prevents duplicates on refresh)
          dotsContainer.innerHTML = '';

          // Create dots in reverse order (rightmost = newest)
          manifest.slice().reverse().forEach((img, reverseIndex) => {
            const actualIndex = manifest.length - 1 - reverseIndex;
            const dot = document.createElement('div');
            dot.className = 'slideshow-dot' + (actualIndex === 0 ? ' active' : '');
            dot.dataset.index = actualIndex;
            dot.onclick = () => goToSlide(webcam.id, actualIndex);
            dotsContainer.appendChild(dot);
          });
        }

      } catch (error) {
        console.error('Failed to load slideshow for ' + webcam.name + ':', error);
      }
    }

    // Navigate slideshow (no looping)
    function navigateSlideshow(webcamId, direction) {
      const state = slideshowState[webcamId];
      if (!state || !state.images) return;

      const newIndex = state.currentIndex + direction;

      // Don't allow looping - clamp to valid range
      if (newIndex < 0 || newIndex >= state.images.length) return;

      state.currentIndex = newIndex;
      updateSlideshowDisplay(webcamId);
    }

    // Go to specific slide
    function goToSlide(webcamId, index) {
      const state = slideshowState[webcamId];
      if (!state || !state.images) return;

      state.currentIndex = index;
      updateSlideshowDisplay(webcamId);
    }

    // Update slideshow display
    function updateSlideshowDisplay(webcamId) {
      const state = slideshowState[webcamId];
      if (!state) return;

      const card = document.querySelector(`[data-webcam-id="${webcamId}"]`);
      if (!card) return;

      const image = card.querySelector('.webcam-image');
      const currentImage = state.images[state.currentIndex];

      // Update image src
      image.src = state.basePath + currentImage.path + '?t=' + Date.now();

      // Update timestamp
      const timestamp = card.querySelector('.webcam-timestamp');
      if (timestamp) {
        const capturedTime = new Date(currentImage.timestamp);
        timestamp.textContent = 'Captured: ' + formatTimestamp(currentImage.timestamp);

        // Add age indicator if not the latest image
        let ageIndicator = card.querySelector('.slideshow-age-indicator');
        if (state.currentIndex > 0) {
          // Find webcam config to get update interval
          const webcam = webcams.find(w => w.id === webcamId);
          const interval = webcam ? (webcam.updateInterval || 10) : 10;
          const minutesAgo = state.currentIndex * interval;
          if (!ageIndicator) {
            ageIndicator = document.createElement('div');
            ageIndicator.className = 'slideshow-age-indicator';
            timestamp.parentNode.insertBefore(ageIndicator, timestamp.nextSibling);
          }
          ageIndicator.textContent = `(${minutesAgo} minutes ago)`;
        } else if (ageIndicator) {
          ageIndicator.remove();
        }
      }

      // Update navigation buttons (disable at ends, no looping)
      const prevBtn = card.querySelector('.slideshow-nav.prev');
      const nextBtn = card.querySelector('.slideshow-nav.next');

      // At latest (index 0): can't go newer (right), can go older (left)
      // At oldest (max index): can't go older (left), can go newer (right)
      if (prevBtn) prevBtn.disabled = state.currentIndex === state.images.length - 1; // Disable left at oldest
      if (nextBtn) nextBtn.disabled = state.currentIndex === 0; // Disable right at newest

      // Update dots (dots are in reverse order, so match by data-index)
      const dots = card.querySelectorAll('.slideshow-dot');
      dots.forEach((dot) => {
        const dotIndex = parseInt(dot.dataset.index);
        dot.classList.toggle('active', dotIndex === state.currentIndex);
      });
    }

    // Auto-refresh webcams every 5 minutes (up to 30 minutes, then stop)
    function startAutoRefresh() {
      const REFRESH_INTERVAL = 5 * 60 * 1000; // 5 minutes
      const MAX_REFRESH_TIME = 30 * 60 * 1000; // 30 minutes
      const startTime = Date.now();
      let refreshCount = 0;

      const intervalId = setInterval(() => {
        const elapsed = Date.now() - startTime;

        // Stop auto-refresh after 30 minutes
        if (elapsed >= MAX_REFRESH_TIME) {
          clearInterval(intervalId);
          console.log('Auto-refresh stopped after 30 minutes. Refresh page to resume.');
          showRefreshNotice();
          return;
        }

        refreshCount++;
        console.log(`Auto-refreshing webcam images... (${refreshCount}/6)`);

        // Clear marine data cache to force refresh
        cachedMarineData = null;

        // Reload marine data and update all webcam cards
        fetchMarineData().then(marineData => {
          webcams.forEach(webcam => {
            const card = document.querySelector(`[data-webcam-id="${webcam.id}"]`);
            if (!card) return;

            // Only refresh image if viewing the latest (index 0)
            const state = slideshowState[webcam.id];
            if (!state || state.currentIndex === 0) {
              const image = card.querySelector('.webcam-image');
              image.src = webcam.imageUrl + '?t=' + Date.now();
            }

            // Update conditions banner (only once, not per webcam)
            if (marineData && webcam === webcams[0]) {
              const existingBanner = document.getElementById('marine-conditions-banner');
              const newBanner = createConditionsBanner(marineData);

              if (existingBanner && newBanner) {
                existingBanner.replaceWith(newBanner);
              } else if (!existingBanner && newBanner) {
                const container = document.getElementById('webcams-container');
                container.parentNode.insertBefore(newBanner, container);
              }
            }

            // Reload slideshow manifest
            loadSlideshow(webcam);
            loadWebcamMetadata(webcam, card);
          });
        });
      }, REFRESH_INTERVAL);
    }

    // Show notice when auto-refresh stops
    function showRefreshNotice() {
      const notice = document.createElement('div');
      notice.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #2c5282;
        color: white;
        padding: 1rem 2rem;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 1000;
        font-size: 0.95rem;
        text-align: center;
      `;
      notice.innerHTML = `
        Auto-refresh stopped after 30 minutes
        <button onclick="location.reload()" style="
          margin-left: 1rem;
          padding: 0.5rem 1rem;
          background: white;
          color: #2c5282;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-weight: 600;
        ">Refresh Page</button>
      `;
      document.body.appendChild(notice);

      // Auto-hide notice after 10 seconds
      setTimeout(() => {
        notice.style.transition = 'opacity 0.5s';
        notice.style.opacity = '0';
        setTimeout(() => notice.remove(), 500);
      }, 10000);
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
      loadWebcams();
      startAutoRefresh();
    });

    // Also load immediately if DOM is already ready
    if (document.readyState === 'loading') {
      // Already set up listener above
    } else {
      loadWebcams();
      startAutoRefresh();
    }
  </script>
  <script src="https://unpkg.com/htmx.org@1.9.10"></script>
</body>
</html>
